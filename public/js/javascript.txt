===== ./compressor.js =====
/*!
 * Compressor.js v1.1.1
 * https://fengyuanchen.github.io/compressorjs
 *
 * Copyright 2018-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2021-10-05T02:32:40.212Z
 */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Compressor = t() }(this, function () { "use strict"; function t(t, e) { var r, i = Object.keys(t); return Object.getOwnPropertySymbols && (r = Object.getOwnPropertySymbols(t), e && (r = r.filter(function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable })), i.push.apply(i, r)), i } function a(i) { for (var e = 1; e < arguments.length; e++) { var a = null != arguments[e] ? arguments[e] : {}; e % 2 ? t(Object(a), !0).forEach(function (e) { var t, r; t = i, e = a[r = e], r in t ? Object.defineProperty(t, r, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : t[r] = e }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(a)) : t(Object(a)).forEach(function (e) { Object.defineProperty(i, e, Object.getOwnPropertyDescriptor(a, e)) }) } return i } function n(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function s() { return (s = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var r, i = arguments[t]; for (r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]) } return e }).apply(this, arguments) } var e, r, o, l, c, h, u, f, i = { exports: {} }; e = i, "undefined" != typeof window && (o = (r = window).HTMLCanvasElement && r.HTMLCanvasElement.prototype, l = r.Blob && function () { try { return Boolean(new Blob) } catch (e) { return !1 } }(), c = l && r.Uint8Array && function () { try { return 100 === new Blob([new Uint8Array(100)]).size } catch (e) { return !1 } }(), h = r.BlobBuilder || r.WebKitBlobBuilder || r.MozBlobBuilder || r.MSBlobBuilder, u = /^data:((.*?)(;charset=.*?)?)(;base64)?,/, f = (l || h) && r.atob && r.ArrayBuffer && r.Uint8Array && function (e) { var t, r, i, a, n, o = e.match(u); if (!o) throw new Error("invalid data URI"); for (t = o[2] ? o[1] : "text/plain" + (o[3] || ";charset=US-ASCII"), i = !!o[4], o = e.slice(o[0].length), r = (i ? atob : decodeURIComponent)(o), i = new ArrayBuffer(r.length), a = new Uint8Array(i), n = 0; n < r.length; n += 1)a[n] = r.charCodeAt(n); return l ? new Blob([c ? a : i], { type: t }) : ((o = new h).append(i), o.getBlob(t)) }, r.HTMLCanvasElement && !o.toBlob && (o.mozGetAsFile ? o.toBlob = function (e, t, r) { var i = this; setTimeout(function () { r && o.toDataURL && f ? e(f(i.toDataURL(t, r))) : e(i.mozGetAsFile("blob", t)) }) } : o.toDataURL && f && (o.msToBlob ? o.toBlob = function (e, t, r) { var i = this; setTimeout(function () { (t && "image/png" !== t || r) && o.toDataURL && f ? e(f(i.toDataURL(t, r))) : e(i.msToBlob(t)) }) } : o.toBlob = function (e, t, r) { var i = this; setTimeout(function () { e(f(i.toDataURL(t, r))) }) })), e.exports ? e.exports = f : r.dataURLtoBlob = f); function j(e) { return 0 < e && e < 1 / 0 } var T = i.exports, d = { strict: !0, checkOrientation: !0, maxWidth: 1 / 0, maxHeight: 1 / 0, minWidth: 0, minHeight: 0, width: void 0, height: void 0, resize: "none", quality: .8, mimeType: "auto", convertTypes: ["image/png"], convertSize: 5e6, beforeDraw: null, drew: null, success: null, error: null }, m = "undefined" != typeof window && void 0 !== window.document ? window : {}, p = Array.prototype.slice; var b = /^image\/.+$/; function R(e) { return b.test(e) } var g = String.fromCharCode; var y = m.btoa; function w(e, t) { for (var r, i = [], a = new Uint8Array(e); 0 < a.length;)i.push(g.apply(null, (r = a.subarray(0, 8192), Array.from ? Array.from(r) : p.call(r)))), a = a.subarray(8192); return "data:".concat(t, ";base64,").concat(y(i.join(""))) } function v(e) { var t, r, i, a, n, o, s, l = new DataView(e); try { if (255 === l.getUint8(0) && 216 === l.getUint8(1)) for (var c = l.byteLength, h = 2; h + 1 < c;) { if (255 === l.getUint8(h) && 225 === l.getUint8(h + 1)) { r = h; break } h += 1 } if (r && (a = r + 10, "Exif" === function (e, t, r) { var i, a = ""; for (r += t, i = t; i < r; i += 1)a += g(e.getUint8(i)); return a }(l, r + 4, 4) && (!(s = 18761 === (n = l.getUint16(a))) && 19789 !== n || 42 !== l.getUint16(a + 2, s) || 8 <= (o = l.getUint32(a + 4, s)) && (i = a + o))), i) for (var u, f = l.getUint16(i, s), d = 0; d < f; d += 1)if (u = i + 12 * d + 2, 274 === l.getUint16(u, s)) { u += 8, t = l.getUint16(u, s), l.setUint16(u, 1, s); break } } catch (e) { t = 1 } return t } var U = /\.\d*(?:0|9){12}\d*$/; function k(e, t) { t = 1 < arguments.length && void 0 !== t ? t : 1e11; return U.test(e) ? Math.round(e * t) / t : e } function x(e, t) { var r = e.aspectRatio, i = e.height, a = e.width, n = 1 < arguments.length && void 0 !== t ? t : "none", o = j(a), e = j(i); return o && e ? (t = i * r, ("contain" === n || "none" === n) && a < t || "cover" === n && t < a ? i = a / r : a = i * r) : o ? i = a / r : e && (a = i * r), { width: a, height: i } } var O = m.ArrayBuffer, B = m.FileReader, A = m.URL || m.webkitURL, M = /\.\w+$/, D = m.Compressor; return function () { function r(e, t) { !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, r), this.file = e, this.image = new Image, this.options = a(a({}, d), t), this.aborted = !1, this.result = null, this.init() } var e, t, i; return e = r, i = [{ key: "noConflict", value: function () { return window.Compressor = D, r } }, { key: "setDefaults", value: function (e) { s(d, e) } }], (t = [{ key: "init", value: function () { var i, e, a, n = this, o = this.file, t = this.options; e = o, "undefined" != typeof Blob && (e instanceof Blob || "[object Blob]" === Object.prototype.toString.call(e)) ? R(i = o.type) ? A && B ? (O || (t.checkOrientation = !1), A && !t.checkOrientation ? this.load({ url: A.createObjectURL(o) }) : (e = new B, a = t.checkOrientation && "image/jpeg" === i, (this.reader = e).onload = function (e) { var t = e.target.result, r = {}; a ? 1 < (e = v(t)) || !A ? (r.url = w(t, i), 1 < e && s(r, function (e) { var t = 0, r = 1, i = 1; switch (e) { case 2: r = -1; break; case 3: t = -180; break; case 4: i = -1; break; case 5: t = 90, i = -1; break; case 6: t = 90; break; case 7: t = 90, r = -1; break; case 8: t = -90 }return { rotate: t, scaleX: r, scaleY: i } }(e))) : r.url = A.createObjectURL(o) : r.url = t, n.load(r) }, e.onabort = function () { n.fail(new Error("Aborted to read the image with FileReader.")) }, e.onerror = function () { n.fail(new Error("Failed to read the image with FileReader.")) }, e.onloadend = function () { n.reader = null }, a ? e.readAsArrayBuffer(o) : e.readAsDataURL(o))) : this.fail(new Error("The current browser does not support image compression.")) : this.fail(new Error("The first argument must be an image File or Blob object.")) : this.fail(new Error("The first argument must be a File or Blob object.")) } }, { key: "load", value: function (e) { var t = this, r = this.file, i = this.image; i.onload = function () { t.draw(a(a({}, e), {}, { naturalWidth: i.naturalWidth, naturalHeight: i.naturalHeight })) }, i.onabort = function () { t.fail(new Error("Aborted to load the image.")) }, i.onerror = function () { t.fail(new Error("Failed to load the image.")) }, m.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(m.navigator.userAgent) && (i.crossOrigin = "anonymous"), i.alt = r.name, i.src = e.url } }, { key: "draw", value: function (e) { var t = this, r = e.naturalWidth, i = e.naturalHeight, a = e.rotate, n = void 0 === a ? 0 : a, o = e.scaleX, s = void 0 === o ? 1 : o, l = e.scaleY, c = void 0 === l ? 1 : l, h = this.file, u = this.image, f = this.options, d = document.createElement("canvas"), m = d.getContext("2d"), p = Math.abs(n) % 180 == 90, b = ("contain" === f.resize || "cover" === f.resize) && j(f.width) && j(f.height), g = Math.max(f.maxWidth, 0) || 1 / 0, y = Math.max(f.maxHeight, 0) || 1 / 0, w = Math.max(f.minWidth, 0) || 0, a = Math.max(f.minHeight, 0) || 0, o = r / i, e = f.width, l = f.height; p && (g = (v = [y, g])[0], y = v[1], w = (v = [a, w])[0], a = v[1], e = (v = [l, e])[0], l = v[1]); var v = x({ aspectRatio: o = b ? e / l : o, width: g, height: y }, "contain"); g = v.width, y = v.height; v = x({ aspectRatio: o, width: w, height: a }, "cover"); w = v.width, a = v.height, l = b ? (e = (v = x({ aspectRatio: o, width: e, height: l }, f.resize)).width, v.height) : (e = void 0 === (O = (U = x({ aspectRatio: o, width: e, height: l })).width) ? r : O, void 0 === (O = U.height) ? i : O); var U = -(e = Math.floor(k(Math.min(Math.max(e, w), g)))) / 2, O = -(l = Math.floor(k(Math.min(Math.max(l, a), y)))) / 2, w = e, g = l, a = []; b && (y = (o = x({ aspectRatio: o, width: y = r, height: b = i }, { contain: "cover", cover: "contain" }[f.resize])).width, b = o.height, a.push((r - y) / 2, (i - b) / 2, y, b)), a.push(U, O, w, g), p && (e = (B = [l, e])[0], l = B[1]), d.width = e, d.height = l, R(f.mimeType) || (f.mimeType = h.type); var B = "transparent"; h.size > f.convertSize && 0 <= f.convertTypes.indexOf(f.mimeType) && (f.mimeType = "image/jpeg"), "image/jpeg" === f.mimeType && (B = "#fff"), m.fillStyle = B, m.fillRect(0, 0, e, l), f.beforeDraw && f.beforeDraw.call(this, m, d), this.aborted || (m.save(), m.translate(e / 2, l / 2), m.rotate(n * Math.PI / 180), m.scale(s, c), m.drawImage.apply(m, [u].concat(a)), m.restore(), f.drew && f.drew.call(this, m, d), this.aborted || (m = function (e) { t.aborted || t.done({ naturalWidth: r, naturalHeight: i, result: e }) }, d.toBlob ? d.toBlob(m, f.mimeType, f.quality) : m(T(d.toDataURL(f.mimeType, f.quality))))) } }, { key: "done", value: function (e) { var t = e.naturalWidth, r = e.naturalHeight, i = e.result, a = this.file, n = this.image, e = this.options; A && !e.checkOrientation && A.revokeObjectURL(n.src), !i || e.strict && i.size > a.size && e.mimeType === a.type && !(e.width > t || e.height > r || e.minWidth > t || e.minHeight > r || e.maxWidth < t || e.maxHeight < r) ? i = a : (r = new Date, i.lastModified = r.getTime(), i.lastModifiedDate = r, i.name = a.name, i.name && i.type !== a.type && (i.name = i.name.replace(M, (a = R(a = i.type) ? a.substr(6) : "", ".".concat(a = "jpeg" === a ? "jpg" : a))))), this.result = i, e.success && e.success.call(this, i) } }, { key: "fail", value: function (e) { var t = this.options; if (!t.error) throw e; t.error.call(this, e) } }, { key: "abort", value: function () { this.aborted || (this.aborted = !0, this.reader ? this.reader.abort() : this.image.complete ? this.fail(new Error("The compression process has been aborted.")) : (this.image.onload = null, this.image.onabort())) } }]) && n(e.prototype, t), i && n(e, i), r }() });

===== ./cumul.js =====
let chart = null;

function renderChart() {
    if (chart) {
        chart.destroy();
    }

    const ctx = document.getElementById('cumulChart').getContext('2d');
    const startMonth = document.getElementById('start-month').value;
    const endMonth = document.getElementById('end-month').value;

    if (startMonth > endMonth) {
        alert('Start month cannot be later than end month');
        return;
    }

    fetch(`/charts/cumul-data?startMonth=${startMonth}&endMonth=${endMonth}`)
        .then(response => response.json())
        .then(data => {
            const formattedData = formatChartData(data);

            chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: formattedData.labels,
                    datasets: [
                        {
                            label: 'Cumul des Idées Émises',
                            data: formattedData.data,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 1,
                            fill: true,
                            type: 'bar',
                        },
                        {
                            label: 'Prévision Cumulative',
                            data: formattedData.prediction,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            fill: false,
                            type: 'line',
                            tension: 0.1,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            type: 'category',
                            labels: formattedData.labels,
                            title: {
                                display: true,
                                text: 'Mois',
                                font: {
                                    size: 14
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Cumul des Propositions',
                                font: {
                                    size: 14
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                font: {
                                    size: 14
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function (tooltipItem) {
                                    return tooltipItem.raw.toFixed(0) + " propositions";
                                }
                            }
                        }
                    }
                }
            });
        })
        .catch(error => console.error('Error fetching data:', error));
}

function exponentialSmoothing(data, alpha = 0.2) {
    let smoothedData = [data[0]];

    for (let i = 1; i < data.length; i++) {
        smoothedData.push(alpha * data[i] + (1 - alpha) * smoothedData[i - 1]);
    }

    return smoothedData;
}

function formatChartData(data) {
    const labels = [];
    const chartData = [];
    const predictionData = [];

    let cumulative = 0;
    data.forEach(item => {
        const monthYear = new Date(item.year, item.month - 1).toLocaleString('default', { month: 'short', year: 'numeric' });
        labels.push(monthYear);
        cumulative += item.cumul_idee_emises;
        chartData.push(cumulative);
    });

    const smoothedData = exponentialSmoothing(chartData);

    const futureStartMonth = data[data.length - 1]?.month || new Date().getMonth() + 1;
    const futureStartYear = data[data.length - 1]?.year || new Date().getFullYear();
    let predictedCumulative = smoothedData[smoothedData.length - 1];

    for (let i = 0; i < 10; i++) {
        predictedCumulative += smoothedData[smoothedData.length - 1] * 0.05;
        const nextMonth = new Date(futureStartYear, futureStartMonth + i, 1);
        const monthYear = nextMonth.toLocaleString('default', { month: 'short', year: 'numeric' });
        labels.push(monthYear);
        predictionData.push(predictedCumulative);
    }

    return {
        labels: labels,
        data: smoothedData,
        prediction: predictionData
    };
}

document.getElementById('filter-form').addEventListener('submit', function (event) {
    event.preventDefault();
    renderChart();
});


===== ./detailProposition.js =====
function confirmDelete(propositionId) {
    Swal.fire({
        title: "Êtes-vous sûr de vouloir supprimer cette proposition ?",
        icon: 'warning',
        showCancelButton: true,
        confirmButtonText: 'Oui',
        cancelButtonText: 'Non'
    }).then((result) => {
        if (result.isConfirmed) {
            fetch(`/propositions/${propositionId}/delete`, {
                method: 'DELETE'
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        window.history.back();
                    } else {
                        Swal.fire("Erreur", data.message, "error");
                    }
                });
        }
    });
}

function openModal(imageSrc) {
    const modal = document.getElementById('imageModal');
    const modalImg = document.getElementById('modalImage');
    const downloadLink = document.getElementById('downloadLink');

    modal.style.display = 'flex';
    modalImg.src = imageSrc;
    downloadLink.href = imageSrc;
}

window.onclick = function (event) {
    const modal = document.getElementById('imageModal');
    if (event.target === modal) {
        closeModal();
    }
};

function closeModal() {
    const modal = document.getElementById('imageModal');
    modal.style.display = 'none';
}

const url = window.location.pathname;
const segments = url.split('/');
const id = segments[segments.length - 1];
Dropzone.options.beforeDropzone = {
    paramName: "beforeImages",
    acceptedFiles: "image/*",
    thumbnailWidth: 250,
    thumbnailHeight: 250,
    dictCancelUpload: 'Annuler',
    addRemoveLinks: true,
    autoProcessQueue: false,
    clickable: "#add1",
    dictDefaultMessage: '',
    dictRemoveFile: '<i class="fas fa-trash-alt"></i>',
    init: function () {
        let myDropzone = this;
        let isUploading = false;

        this.on("error", function (file, response) {
            const deleteButton = file.previewElement.querySelector(".dz-remove");
            if (deleteButton) {
                deleteButton.style.display = "none";
            }
            console.error('Upload error:', response);
        });

        this.on("success", function (file, response) {
            file.id = response.uploadedFiles[0].fileId;
            file.size = response.uploadedFiles[0].size;
            refreshGallery('before');
            isUploading = false; // Mark upload as finished
            processNextFile(); // Start the next file upload
        });

        this.on("sending", function (file, xhr, formData) {
            if (!file.compressed) {
                xhr.abort();
                console.log('File not compressed. Aborting upload.');
            } else {
                isUploading = true; // Mark upload as in progress
            }
        });

        this.on("removedfile", function (file) {
            if (file.id && file.compressed) {
                fetch(`/images/delete/${file.id}`, {
                    method: 'DELETE'
                })
                    .then(response => response.json())
                    .then(result => {
                        if (!result.success) {
                            let mockFile = {
                                name: file.name,
                                size: file.size,
                                id: file.id
                            };
                            this.displayExistingFile(mockFile, `/images/${id}/before/${file.name}`);
                            mockFile.previewElement.classList.add("dz-complete");
                        } else {
                            refreshGallery('before');
                        }
                    }).catch(error => {
                        console.error('Error removing file:', error);
                    });
            }
        });

        this.on("addedfile", function (file) {
            if (file.compressed) {
                processNextFile();
                return;
            }
            if (file.size < 200) {
                file.compressed = true;
                processNextFile();
                return;
            }
            const compressionRatio = 0.9;

            new Compressor(file, {
                quality: compressionRatio,
                maxWidth: 800,
                maxHeight: 600,
                success: function (result) {
                    myDropzone.removeFile(file);
                    result.compressed = true;
                    myDropzone.addFile(result);
                    processNextFile(); // Start the upload after compression
                },
                error: function (err) {
                    console.error('Error compressing image:', err);
                }
            });
        });

        function processNextFile() {
            if (!isUploading && myDropzone.getQueuedFiles().length > 0) {
                const nextFile = myDropzone.getQueuedFiles()[0];
                if (nextFile.compressed) { // Only process if compressed
                    myDropzone.processFile(nextFile); // Process the file
                } else {
                    console.log('Next file is not compressed, skipping upload.');
                }
            } else {
                console.log('No files in queue or already uploading.');
            }
        }

        this.on("queuecomplete", function () {
            console.log('All files have been processed.');
        });

        fetch(`/images/proposition/${id}?type=before`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    data.images.forEach(file => {
                        let mockFile = {
                            name: file.filename,
                            size: file.file_size,
                            id: file.id,
                            compressed: true
                        };
                        this.displayExistingFile(mockFile, `/images/${id}/before/${file.filename}`);
                        mockFile.previewElement.classList.add("dz-complete");
                        const removeButton = mockFile.previewElement.querySelector(".dz-remove");
                        removeButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
                    });
                }
            });
    }
};

Dropzone.options.afterDropzone = {
    paramName: "afterImages",
    acceptedFiles: "image/*",
    thumbnailWidth: "250",
    thumbnailHeight: "250",
    dictCancelUpload: 'Annuler',
    addRemoveLinks: true,
    clickable: "#add2",
    dictDefaultMessage: '',
    dictRemoveFile: '<i class="fas fa-trash-alt"></i>',
    autoProcessQueue: false,
    init: function () {
        let myDropzone = this;
        this.on("error", function (file, response) {
            var deleteButton = file.previewElement.querySelector(".dz-remove");
            if (deleteButton) {
                deleteButton.style.display = "none";
            }

            var errorMark = file.previewElement;
            if (errorMark) {
                errorMark.addEventListener("click", function () {
                    deleteButton.click();
                });
            }
        })

        this.on("success", function (file, response) {
            file.id = response.uploadedFiles[0].fileId;
            file.size = response.uploadedFiles[0].size;
            refreshGallery('after');
        });

        this.on("removedfile", function (file) {
            if (file.id) {
                fetch(`/images/delete/${file.id}`, {
                    method: 'DELETE'
                })
                    .then(response => response.json())
                    .then(result => {
                        if (!result.success) {
                            let mockFile = {
                                name: file.name,
                                size: file.size,
                                id: file.id
                            };
                            this.displayExistingFile(mockFile, `/images/${id}/after/${file.name}`);
                            mockFile.previewElement.classList.add("dz-complete");
                        } else {
                            refreshGallery('after');
                        }
                    }).catch(error => {
                        let mockFile = {
                            name: file.name,
                            size: file.size,
                            id: file.id
                        };
                        this.displayExistingFile(mockFile, `/images/${id}/after/${file.name}`);
                        mockFile.previewElement.classList.add("dz-complete");
                    });
            }
        });

        this.on("addedfile", function (file) {
            if (file.compressed) {
                return;
            }
            if (file.size < 200) {
                file.compressed = true;
                return;
            }

            myDropzone.removeFile(file);

            const compressionRatio = 0.9;

            new Compressor(file, {
                quality: compressionRatio,
                maxWidth: 800,
                maxHeight: 600,
                success: function (result) {
                    result.compressed = true;
                    myDropzone.addFile(result);
                    myDropzone.uploadFile(result);

                },
                error: function (err) {
                    console.error('Error compressing image:', err);
                }
            });
        });

        fetch(`/images/proposition/${id}?type=after`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    data.images.forEach(file => {
                        let mockFile = {
                            name: file.filename,
                            size: file.file_size,
                            id: file.id,
                            compressed: true
                        };
                        this.displayExistingFile(mockFile, `/images/${id}/after/${file.filename}`);
                        mockFile.previewElement.classList.add("dz-complete");
                        const removeButton = mockFile.previewElement.querySelector(".dz-remove");
                        removeButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
                    });
                }
            })
    }
};

function openForm(type) {
    document.body.classList.add('popup-active'); // Disable body scrolling

    if (type === 'before') {
        document.getElementById('popupFormBefore').style.display = 'flex';
    } else if (type === 'after') {
        document.getElementById('popupFormAfter').style.display = 'flex';
    }
}

function closeForm(type) {
    document.body.classList.remove('popup-active'); // Re-enable body scrolling

    if (type === 'before') {
        document.getElementById('popupFormBefore').style.display = 'none';
    } else if (type === 'after') {
        document.getElementById('popupFormAfter').style.display = 'none';
    }
}

const forms = document.querySelectorAll('.dropzone');
let observing = true;

function updateImages() {
    if (!observing) return;
    observing = false;
    forms.forEach(form => {
        const childCount = form.children.length - 1;
        const image = form.querySelector('.add-wrapper');
        if (childCount < 4) {
            form.appendChild(image);
            image.style.display = 'flex';
        } else {
            image.style.display = 'none';
        }
    });

    setTimeout(() => {
        observing = true;
    }, 0)
}

forms.forEach(form => {
    const observer = new MutationObserver(updateImages);
    observer.observe(form, {
        childList: true
    });
});

function refreshGallery(type) {
    fetch(`/images/proposition/${id}?type=${type}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const galleryContainer = document.querySelector(`.image-gallery[data-type="${type}"]`);
                if (data.images.length > 0) {
                    galleryContainer.innerHTML = data.images.map(image => `
    <div class="image-wrapper" onclick="openModal('/images/${id}/${type}/${image.filename}')">
      <img src="/images/${id}/${type}/${image.filename}" alt="Image ${type === 'before' ? 'Avant' : 'Après'}" class="image-thumbnail">
    </div>
    `).join('');
                } else {
                    galleryContainer.innerHTML = `<p class="no-images-message">Aucune image "${type === 'before' ? 'Avant' : 'Après'}" disponible.</p>`;
                }
            } else {
                console.error('Error fetching images:', data.message);
            }
        })
        .catch(error => {
            console.error('Error updating image gallery:', error);
        });
}

document.addEventListener('DOMContentLoaded', () => {
    refreshGallery('before');
    refreshGallery('after');
    const hash = window.location.hash;

    if (hash === '#before-gallery') {
        const beforeGallery = document.querySelector('.proposition-images .image-gallery[data-type="before"]');
        if (beforeGallery) {
            beforeGallery.scrollIntoView({
                behavior: 'smooth'
            });
        }
        history.replaceState(null, '', window.location.pathname);

        openForm('before');
    }
    setTimeout(() => {
        updateImages();
    }, 2000)
});

===== ./editUser.js =====
Dropzone.options.profileImageDropzone = {
    paramName: "profileImage",
    acceptedFiles: "image/*",
    thumbnailWidth: 100,
    thumbnailHeight: 100,
    autoProcessQueue: false,
    addRemoveLinks: true,
    dictCancelUpload: 'Annuler',
    clickable: "#add",
    maxFiles: 1,
    dictDefaultMessage: '',
    dictRemoveFile: '<i class="fas fa-trash-alt"></i>',
    init: function () {
        let myDropzone = this;
        const formAction = document.querySelector('#profileImageDropzone').action;
        const userId = formAction.split('/').pop();
        const existingImageUrl = `/images/profile-image/${userId}?p=1`;

        fetch(existingImageUrl)
            .then(response => {
                if (response.ok) {
                    return response.blob();
                }
                if (response.status === 404) {
                    return null;
                }
                throw new Error('Erreur lors de la récupération de l\'image.');
            })
            .then(blob => {
                if (blob) {
                    const mockFile = { name: `profileimg-${userId}`, size: blob.size, compressed: true };
                    const imgUrl = URL.createObjectURL(blob);
                    myDropzone.emit("addedfile", mockFile);
                    myDropzone.emit("thumbnail", mockFile, imgUrl);
                    myDropzone.emit("complete", mockFile);
                    myDropzone.files.push(mockFile);
                }
            })
            .catch(error => {
                console.error(`Erreur lors de la récupération de l'image de profil : ${error.message}`);
            });

        this.on("removedfile", function (file) {
            if (file.name && file.compressed) {
                Swal.fire({
                    title: 'Êtes-vous sûr?',
                    text: "Vous ne pourrez pas revenir en arrière!",
                    icon: 'warning',
                    showCancelButton: true,
                    confirmButtonColor: '#3085d6',
                    cancelButtonColor: '#d33',
                    confirmButtonText: 'Oui, supprimer!',
                    cancelButtonText: 'Non, annuler!'
                }).then((result) => {
                    if (result.isConfirmed) {
                        fetch(`/images/profile-image/delete/${userId}`, {
                            method: 'DELETE'
                        })
                            .then(response => response.json())
                            .then(result => {
                                if (result.success) {
                                    Swal.fire(
                                        'Supprimé!',
                                        'Votre image a été supprimée.',
                                        'success'
                                    );
                                } else {
                                    console.error(`Erreur lors de la suppression de l'image de profil: ${result.message}`);
                                    Swal.fire(
                                        'Erreur!',
                                        'Une erreur est survenue lors de la suppression de l\'image.',
                                        'error'
                                    );
                                }
                            })
                            .catch(error => {
                                console.error(`Erreur lors de la suppression de l'image de profil: ${error}`);
                                Swal.fire(
                                    'Erreur!',
                                    'Une erreur est survenue lors de la suppression de l\'image.',
                                    'error'
                                );
                            });
                    } else {
                        fetch(existingImageUrl)
                            .then(response => {
                                if (response.ok) {
                                    return response.blob();
                                }
                                if (response.status === 404) {
                                    return null;
                                }
                                throw new Error('Erreur lors de la récupération de l\'image.');
                            })
                            .then(blob => {
                                if (blob) {
                                    const mockFile = { name: `profileimg-${userId}`, size: blob.size, compressed: true };
                                    const imgUrl = URL.createObjectURL(blob);
                                    myDropzone.emit("addedfile", mockFile);
                                    myDropzone.emit("thumbnail", mockFile, imgUrl);
                                    myDropzone.emit("complete", mockFile);
                                    myDropzone.files.push(mockFile);
                                }
                            })
                            .catch(error => {
                                console.error(`Erreur lors de la récupération de l'image de profil : ${error.message}`);
                            });
                        Swal.fire(
                            'Annulé',
                            'Votre image est en sécurité :)',
                            'info'
                        );
                    }
                });
            }
        });

        this.on("addedfile", function (file) {
            if (file.compressed) {
                return;
            }
            if (file.size < 200) {
                file.compressed = true;
                return;
            }
            myDropzone.removeFile(file);
            const compressionRatio = 0.9;
            new Compressor(file, {
                quality: compressionRatio,
                maxWidth: 800,
                maxHeight: 600,
                mimeType: 'image/jpeg',
                success: function (result) {
                    result.compressed = true;
                    myDropzone.addFile(result);
                    myDropzone.uploadFile(result);
                },
                error: function (err) {
                    console.error('Error compressing image:', err);
                }
            });
        });

        function processFile(file) {
            if (!file.processed) {
                file.processed = true;
                myDropzone.processFile(file);
            }
        }
    }
};

const forms = document.querySelectorAll('.dropzone');
let observing = true;

function updateImages() {
    if (!observing) return;
    observing = false;
    forms.forEach(form => {
        const childCount = form.children.length - 1;
        const image = form.querySelector('.add-wrapper');
        if (childCount == 1) {
            form.appendChild(image);
            image.style.display = 'flex';
            form.style.border = '2px dashed rgb(204, 204, 204)';
        } else {
            image.style.display = 'none';
            form.style.border = 'none';
        }
    });
    setTimeout(() => {
        observing = true;
    }, 0)
}

forms.forEach(form => {
    const observer = new MutationObserver(updateImages);
    observer.observe(form, {
        childList: true
    });
});

===== ./functionList.js =====
document.addEventListener('DOMContentLoaded', () => {

    // Ajouter une fonction
    document.getElementById('addFunctionBtn').addEventListener('click', () => {
        Swal.fire({
            title: 'Ajouter une fonction',
            html: `
        <input type="text" id="newFunctionName" class="swal2-input" placeholder="Nom de la fonction">
      `,
            confirmButtonText: 'Ajouter',
            focusConfirm: false,
            preConfirm: () => {
                const name = document.getElementById('newFunctionName').value;
                if (!name) {
                    Swal.showValidationMessage('Le nom est requis');
                } else {
                    // Appeler le backend pour ajouter la fonction
                    return fetch('/functions', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name })
                    }).then(response => response.json());
                }
            }
        }).then((result) => {
            if (result.isConfirmed) {
                Swal.fire('Succès', 'Fonction ajoutée avec succès', 'success').then(() => location.reload());
            }
        });
    });

    // Modifier une fonction
    document.querySelectorAll('.modifyFunctionBtn').forEach(button => {
        button.addEventListener('click', () => {
            const id = button.getAttribute('data-id');
            const name = button.getAttribute('data-name');

            Swal.fire({
                title: 'Modifier la fonction',
                html: `
          <input type="text" id="modifiedFunctionName" class="swal2-input" value="${name}">
        `,
                confirmButtonText: 'Modifier',
                focusConfirm: false,
                preConfirm: () => {
                    const newName = document.getElementById('modifiedFunctionName').value;
                    if (!newName) {
                        Swal.showValidationMessage('Le nom est requis');
                    } else {
                        // Appeler le backend pour modifier la fonction
                        return fetch(`/functions/edit/${id}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name: newName })
                        }).then(response => response.json());
                    }
                }
            }).then((result) => {
                if (result.isConfirmed) {
                    Swal.fire('Succès', 'Fonction modifiée avec succès', 'success').then(() => location.reload());
                }
            });
        });
    });

    document.querySelectorAll('.deleteFunctionBtn').forEach(button => {
        button.addEventListener('click', () => {
            const id = button.getAttribute('data-id');

            Swal.fire({
                title: 'Êtes-vous sûr ?',
                text: "Vous ne pourrez pas revenir en arrière !",
                icon: 'warning',
                showCancelButton: true,
                confirmButtonText: 'Oui, supprimer',
                cancelButtonText: 'Annuler'
            }).then((result) => {
                if (result.isConfirmed) {
                    fetch(`/functions/delete/${id}`, {
                        method: 'DELETE'
                    }).then(response => response.json())
                        .then(() => {
                            Swal.fire('Supprimée !', 'La fonction a été supprimée.', 'success').then(() => location.reload());
                        });
                }
            });
        });
    });
});


===== ./global-vote.js =====
document.addEventListener('DOMContentLoaded', () => {
    const submitVoteBtn = document.getElementById('submit-vote-btn');
    let currentIndex = 0;
    const propositions = JSON.parse(document.getElementById('propositions-data').value);
    const totalPropositions = propositions.length;

    const votes = Array(totalPropositions).fill(null);

    function renderProposition(index) {
        disableUsed(index);
        checkNoVotes();
        const proposition = propositions[index];
        document.getElementById('pagination').innerText = `${index + 1}/${totalPropositions}`;
        document.getElementById('proposition-objet').innerText = proposition.objet;
        document.getElementById('proposition-description-situation').innerText = proposition.description_situation_actuelle;
        document.getElementById('proposition-description-amelioration').innerText = proposition.description_amelioration_proposee;
        document.getElementById('proposition-status').innerText = proposition.statut === 'soldee' ? 'Soldée' : proposition.statut === 'en cours' ? 'En Cours' : proposition.statut === 'anulee' ? 'Annulée' : 'Non Soldée';
        document.getElementById('proposition-status').classList = `status ${proposition.statut}`;
        const impactsList = document.getElementById('proposition-impacts');
        impactsList.innerHTML = '';
        if (proposition.impact_economique) impactsList.innerHTML += `<li class="impact-item">💡 Impact économique</li>`;
        if (proposition.impact_technique) impactsList.innerHTML += `<li class="impact-item">🔧 Impact technique</li>`;
        if (proposition.impact_formation) impactsList.innerHTML += `<li class="impact-item">📚 Impact de formation</li>`;
        if (proposition.impact_fonctionnement) impactsList.innerHTML += `<li class="impact-item">⚙️ Impact de fonctionnement</li>`;

        renderImages(proposition.id, 'before', proposition.before_images);
        renderImages(proposition.id, 'after', proposition.after_images);

        const voteValue = votes[index];
        if (voteValue !== null) {
            document.querySelector(`input[name="grade"][value="${voteValue}"]`).checked = true;
        } else {
            const selectedRadio = document.querySelector('input[name="grade"]:checked');
            if (selectedRadio) {
                selectedRadio.checked = false;
            }
        }
    }

    function renderImages(id, type, images) {
        const galleryContainer = document.getElementById(`${type}-images`);
        if (images && images.split(',').length > 0) {
            galleryContainer.innerHTML = images.split(',').map(image => `
                <div class="image-wrapper" onclick="openModal('/images/${id}/${type}/${image}')">
                    <img src="/images/${id}/${type}/${image}" alt="Image ${type}" class="image-thumbnail">
                </div>
            `).join('');
        } else {
            galleryContainer.innerHTML = `<p class="no-images-message">Aucune image disponible.</p>`;
        }
    }
    function disableUsed(index) {
        const radios = document.querySelectorAll('.grade');

        radios.forEach(radio => {
            radio.disabled = false;
        });

        const currentVote = votes[index];

        for (let i = 1; i <= 6; i++) {
            const isDisabled = votes.some((v, idx) => (v === i && idx !== index));
            if (isDisabled) {
                radios[i - 1].disabled = true;
            }
        }
    }

    function checkNoVotes() {
        disabled = !votes.some(value => value !== null);
        console.log(disabled);

        submitVoteBtn.disabled = disabled;
    }

    renderProposition(currentIndex);

    document.getElementById('next-btn').addEventListener('click', () => {
        const voteValue = document.querySelector('input[name="grade"]:checked')?.value;
        votes[currentIndex] = voteValue ? parseInt(voteValue) : null;

        if (currentIndex < totalPropositions - 1) {
            currentIndex++;
            renderProposition(currentIndex);
        }
    });

    document.getElementById('prev-btn').addEventListener('click', () => {
        const voteValue = document.querySelector('input[name="grade"]:checked')?.value;
        votes[currentIndex] = voteValue ? parseInt(voteValue) : null;

        if (currentIndex > 0) {
            currentIndex--;
            renderProposition(currentIndex);
        }
    });

    submitVoteBtn.addEventListener('click', async () => {
        const voteValue = document.querySelector('input[name="grade"]:checked')?.value;
        votes[currentIndex] = voteValue ? parseInt(voteValue) : null;
        console.log(votes);

        const filteredVotes = propositions
            .map((proposition, index) => ({
                propositionId: proposition.id,
                value: votes[index]
            }))
            .filter(vote => vote.vote_value !== null);

        if (filteredVotes.length === 0) {
            alert('Veuillez voter sur au moins une proposition avant de soumettre.');
            return;
        }

        try {
            const response = await fetch('/voting-sessions/global-vote/submit', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ votes: filteredVotes })
            });

            const result = await response.json();
            if (response.ok) {
                alert(result.message);
            } else {
                alert(result.message || 'Erreur lors de la soumission du vote');
            }
        } catch (error) {
            console.error('Erreur lors de la soumission:', error);
        }
    });

    document.querySelectorAll('.grade').forEach(radio => {
        radio.addEventListener('click', function (e) {
            e.preventDefault();
            setTimeout(() => {
                if (this.checked === true) {
                    this.checked = false;
                } else {
                    this.checked = true;
                }
                const voteValue = document.querySelector('input[name="grade"]:checked')?.value;
                votes[currentIndex] = voteValue ? parseInt(voteValue) : null;
                checkNoVotes()

            }, 0)
        });
    });

});

function openModal(imageSrc) {
    const modal = document.getElementById('imageModal');
    const modalImg = document.getElementById('modalImage');
    const downloadLink = document.getElementById('downloadLink');

    modal.style.display = 'flex';
    modalImg.src = imageSrc;
    downloadLink.href = imageSrc;
}

window.onclick = function (event) {
    const modal = document.getElementById('imageModal');
    if (event.target === modal) {
        closeModal();
    }
};

function closeModal() {
    const modal = document.getElementById('imageModal');
    modal.style.display = 'none';
}


===== ./mespropositions.js =====
document.addEventListener('DOMContentLoaded', () => {
    const columnDefs = [{
        headerName: "ID",
        field: "id",
        sortable: true,
        filter: true,
        resizable: true,
        flex: 1,
        sort: 'desc',
        minWidth: 100,
        maxWidth: 100
    },
    {
        headerName: "Objet",
        field: "objet",
        sortable: true,
        filter: true,
        resizable: true,
        flex: 2,
        minWidth: 200
    },
    {
        headerName: "Situation Actuelle",
        field: "description_situation_actuelle",
        sortable: true,
        filter: true,
        resizable: true,
        flex: 3,
        minWidth: 300
    },
    {
        headerName: "Amélioration Proposée",
        field: "description_amelioration_proposee",
        sortable: true,
        filter: true,
        resizable: true,
        flex: 3,
        minWidth: 300
    },
    {
        headerName: "Date",
        field: "date_emission",
        sortable: true,
        flex: 1.5,
        valueFormatter: params => params.value ? new Date(params.value).toLocaleDateString('fr-FR') : '',
        minWidth: 150
    },
    {
        sortable: false,
        filter: false,
        headerName: "Actions",
        cellRenderer: 'buttonRenderer',
        maxWidth: 120,
        minWidth: 100
    }
    ];

    const dataContainer = document.getElementById('dataContainer');
    const rowData = JSON.parse(dataContainer.getAttribute('data-row-data'));

    const buttonRenderer = (params) => {
        const button = document.createElement('button');
        button.innerText = 'Détails';
        button.className = 'button secondary';
        button.onclick = (event) => {
            event.stopPropagation();
            window.location.href = `/propositions/proposition/${params.data.id}`;
        };
        return button;
    };

    const gridOptions = {
        columnDefs: columnDefs,
        rowData: rowData,
        defaultColDef: {
            sortable: true,
            filter: true,
            resizable: true,
            minWidth: 100
        },
        localeText: AG_GRID_LOCALE_FR,
        pagination: true,
        paginationPageSize: 50,
        domLayout: 'autoHeight',
        suppressRowClickSelection: true,
        components: {
            buttonRenderer: buttonRenderer
        },
        onRowClicked: params => {
            showRowDetails(params.data);
        },
        onGridReady: params => {
            params.api.refreshCells({
                force: true
            });
        }
    };

    const eGridDiv = document.querySelector('#myGrid');
    agGrid.createGrid(eGridDiv, gridOptions);

    const modal = document.getElementById('myModal');
    const closeButton = document.querySelector('.close');
    const rowDetails = document.getElementById('rowDetails');
    const viewDetailsButton = document.getElementById('viewDetailsButton');

    function showRowDetails(data) {
        rowDetails.innerHTML = `
          <p><strong>ID:</strong> ${data.id}</p>
          <p><strong>Objet:</strong> ${escapeHtml(data.objet)}</p>
          <p><strong>Situation Actuelle:</strong> ${escapeHtml(data.description_situation_actuelle)}</p>
          <p><strong>Amélioration Proposée:</strong> ${escapeHtml(data.description_amelioration_proposee)}</p>
          <p><strong>Date:</strong> ${new Date(data.date_emission).toLocaleDateString('fr-FR')}</p>
        `;
        modal.style.display = 'flex';

        viewDetailsButton.onclick = () => {
            window.location.href = `/propositions/proposition/${data.id}`;
        };
    }

    closeButton.onclick = () => {
        modal.style.display = 'none';
    };

    window.onclick = event => {
        if (event.target === modal) {
            modal.style.display = 'none';
        }
    };
});

===== ./navbar.js =====
let dropdowns = document.querySelectorAll('.navbar-dropdown');
let activeDropdown = null;  // Store the currently active dropdown

if (dropdowns.length) {
    dropdowns.forEach((dropdown) => {
        let toggler = dropdown.querySelector('.dropdown-toggler'); // The <a> tag with the dropdown-toggler class

        if (toggler) {
            toggler.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent click event from bubbling up to the window

                // Check if the click was on the <a> or its children (e.g., <i> element)
                let target = document.querySelector(`#${event.target.closest('a').dataset.dropdown}`);

                // If a dropdown is already open and it's not the one clicked, close it
                if (activeDropdown && activeDropdown !== target) {
                    activeDropdown.classList.remove('show');
                }

                // Toggle the clicked dropdown visibility
                if (target) {
                    target.classList.toggle('show');
                    // If the dropdown is now open, set it as the active dropdown
                    activeDropdown = target.classList.contains('show') ? target : null;
                }
            });
        }
    });
}

// Close dropdowns when clicking outside
window.addEventListener('click', (event) => {
    if (activeDropdown && !event.target.closest('.navbar-dropdown')) {
        activeDropdown.classList.remove('show');
        activeDropdown = null;
    }
});

// Handle small screen toggler
function handleSmallScreens() {
    document.querySelector('.navbar-toggler').addEventListener('click', () => {
        let navbarMenu = document.querySelector('.navbar-menu');

        // Toggle the menu visibility for small screens
        navbarMenu.classList.toggle('active');
    });
}

handleSmallScreens();


===== ./pie-chart.js =====
document.addEventListener('DOMContentLoaded', function () {
    const yearSelector = document.getElementById('yearSelector');
    const monthSelector = document.getElementById('monthSelector');
    const pieChartCanvas = document.getElementById('pieChart');
    let pieChart;

    async function fetchYears() {
        try {
            const response = await fetch('/charts/years');
            const years = await response.json();

            yearSelector.innerHTML = '';
            years.forEach(year => createYearCheckbox(year));
            fetchMonths();
            fetchPieChartData();
        } catch (error) {
            console.error('Erreur lors de la récupération des années:', error);
        }
    }

    function createYearCheckbox(year) {
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = year;
        checkbox.id = `year-${year}`;
        checkbox.addEventListener('change', function () {
            fetchMonths();
            fetchPieChartData();
        });
        checkbox.checked = true;

        const label = document.createElement('label');
        label.htmlFor = `year-${year}`;
        label.textContent = year;

        yearSelector.appendChild(checkbox);
        yearSelector.appendChild(label);
    }

    async function fetchMonths() {
        const selectedYears = Array.from(yearSelector.querySelectorAll('input:checked')).map(input => input.value);

        if (selectedYears.length === 0) {
            monthSelector.innerHTML = '';
            return;
        }

        try {
            const response = await fetch(`/charts/months?years=${selectedYears.join(',')}`);
            const monthsData = await response.json();
            monthSelector.innerHTML = '';

            const monthsByYear = monthsData.reduce((acc, { month, year }) => {
                if (!acc[year]) acc[year] = [];
                acc[year].push(month);
                return acc;
            }, {});

            Object.keys(monthsByYear).forEach(year => {
                const yearSection = document.createElement('div');
                yearSection.classList.add('year-group');
                yearSection.innerHTML = `<h3>${year}</h3>`;

                monthsByYear[year].forEach(month => {
                    const monthLabel = new Date(0, month - 1).toLocaleString('fr', { month: 'long' });
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = `${month}-${year}`;
                    checkbox.id = `month-${month}-${year}`;
                    checkbox.checked = true;
                    checkbox.addEventListener('change', fetchPieChartData); // Call fetchPieChartData here

                    const label = document.createElement('label');
                    label.htmlFor = `month-${month}-${year}`;
                    label.textContent = `${monthLabel} ${year}`;

                    yearSection.appendChild(checkbox);
                    yearSection.appendChild(label);
                });

                monthSelector.appendChild(yearSection);
            });

            fetchPieChartData();
        } catch (error) {
            console.error('Erreur lors de la récupération des mois:', error);
        }
    }

    async function fetchPieChartData() {
        const years = getSelectedValues(yearSelector);
        const months = getSelectedValues(monthSelector);

        if (years.length === 0 || months.length === 0) return;

        try {
            const response = await fetch(`/charts/pie-chart-data?years=${years.join(',')}&months=${months.join(',')}`);
            const data = await response.json();
            updateTable(data);
            updatePieChart(data);
        } catch (error) {
            console.error('Erreur lors de la récupération des données du graphique:', error);
        }
    }

    function updateTable(data) {
        const tableBody = document.getElementById('tableBody');
        tableBody.innerHTML = '';

        let totalRetenu = 0;
        let totalEnCours = 0;
        let grandTotal = 0;

        data.forEach(row => {
            const [month, year] = row.month.split('-');
            const monthName = new Date(0, month - 1).toLocaleString('fr', { month: 'long' });

            // Calculate totals
            totalRetenu += row.nb_propositions_retenu;
            totalEnCours += row.nb_propositions_en_cours;

            // Total for this row
            const total = row.nb_propositions_retenu + row.nb_propositions_en_cours;
            grandTotal += total;

            const tableRow = `<tr>
            <td>${monthName} ${year}</td>
            <td>${row.nb_propositions_retenu}</td>
            <td>${row.nb_propositions_en_cours}</td>
            <td>${total}</td>
        </tr>`;
            tableBody.innerHTML += tableRow;
        });

        // Add total row at the bottom
        const totalRow = `<tr>
        <td><strong>Total</strong></td>
        <td><strong>${totalRetenu}</strong></td>
        <td><strong>${totalEnCours}</strong></td>
        <td><strong>${grandTotal}</strong></td>
    </tr>`;
        tableBody.innerHTML += totalRow;
    }


    function updatePieChart(data) {
        const retenuCount = data.reduce((sum, row) => sum + row.nb_propositions_retenu, 0);
        const nonRetenuCount = data.reduce((sum, row) => sum + row.nb_propositions_en_cours, 0);

        const chartData = {
            labels: ['Propositions Soldée', 'Propositions en cours'],
            datasets: [{
                data: [retenuCount, nonRetenuCount],
                backgroundColor: ['#4caf50', '#f44336'],
            }]
        };

        if (pieChart) pieChart.destroy();
        pieChart = new Chart(pieChartCanvas, {
            type: 'pie',
            data: chartData,
            options: {
                responsive: true,
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: context => `${context.label}: ${context.raw} (${((context.raw / (retenuCount + nonRetenuCount)) * 100).toFixed(2)}%)`
                        }
                    }
                }
            }
        });
    }

    function getSelectedValues(container) {
        return Array.from(container.querySelectorAll('input:checked')).map(input => input.value);
    }

    fetchYears();
});


===== ./propositionForm.js =====
const textElements = document.querySelectorAll('input[type="text"], textarea');

textElements.forEach((element) => {
    const counter = element.nextElementSibling;
    const maxLength = element.getAttribute('maxlength');

    const currentLength = element.value.length;
    counter.textContent = `${currentLength} / ${maxLength}`;

    if (currentLength >= maxLength) {
        counter.classList.add('warning');
    } else {
        counter.classList.remove('warning');
    }
    element.addEventListener('input', function () {
        const currentLength = element.value.length;
        counter.textContent = `${currentLength} / ${maxLength}`;

        if (currentLength >= maxLength) {
            counter.classList.add('warning');
        } else {
            counter.classList.remove('warning');
        }
    });
});

const form = document.getElementById('upload-form');
const errorMessageContainer = document.getElementById('error-message');
form.addEventListener('keydown', function (event) {
    if (event.key === 'Enter') event.preventDefault();
});
form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const formData = new FormData(form);
    try {
        const response = await fetch('/propositions/add', {
            method: 'POST',
            body: formData
        });

        const result = await response.json();
        console.log(result);

        if (response.ok) {
            Swal.fire({
                title: 'Proposition ajoutée!',
                icon: 'success',
                showCancelButton: true,
                confirmButtonText: 'Ajouter des images',
                cancelButtonText: 'Pas maintenant',
                allowOutsideClick: false,
                preConfirm: () => {
                    window.location.href = '/propositions/proposition/' + result.propositionId + '#before-gallery';
                }
            }).then((result) => {
                if (result.dismiss === Swal.DismissReason.cancel) {
                    window.location.href = '/propositions/mes-propositions';
                }
            });
        } else {
            Swal.fire({
                title: 'Erreur!',
                icon: 'error',
                confirmButtonText: 'Ok',
                allowOutsideClick: false
            });
        }
    } catch (error) {
        Swal.fire({
            title: 'Erreur inconnue!',
            text: 'Une erreur inattendue s\'est produite. Veuillez réessayer plus tard ou contacter le support.',
            icon: 'error',
            timer: 1000,
            showConfirmButton: false,
            allowOutsideClick: false
        }).then(function () {
            window.location.href = '/';
        });
    }
});

===== ./propositionFormUpdate.js =====
const textElements = document.querySelectorAll('input[type="text"], textarea');

textElements.forEach((element) => {
    const counter = element.nextElementSibling;
    const maxLength = element.getAttribute('maxlength');

    const currentLength = element.value.length;
    counter.textContent = `${currentLength} / ${maxLength}`;

    if (currentLength >= maxLength) {
        counter.classList.add('warning');
    } else {
        counter.classList.remove('warning');
    }
    element.addEventListener('input', function () {
        const currentLength = element.value.length;
        counter.textContent = `${currentLength} / ${maxLength}`;

        if (currentLength >= maxLength) {
            counter.classList.add('warning');
        } else {
            counter.classList.remove('warning');
        }
    });
});
const form = document.getElementById('upload-form');

const errorMessageContainer = document.getElementById('error-message');

form.addEventListener('keydown', function (event) {
    if (event.key === 'Enter') event.preventDefault();
});

form.addEventListener('submit', async (event) => {

    event.preventDefault();
    const formData = new FormData(form);

    const url = form.getAttribute('action');

    try {
        const response = await fetch(url, {
            method: 'POST',
            body: formData
        });

        const result = await response.json();
        console.log(result);

        if (response.ok) {
            Swal.fire({
                title: 'Proposition modifiée avec succès !',
                icon: 'success',
                showCancelButton: true,
                confirmButtonText: 'Ajouter des images',
                cancelButtonText: 'Pas maintenant',
                allowOutsideClick: false,
                preConfirm: () => {
                    window.location.href = '/propositions/proposition/' + result.propositionId + '#before-gallery';
                }
            }).then((swalResult) => {
                if (swalResult.dismiss === Swal.DismissReason.cancel) {
                    window.location.href = '/propositions/mes-propositions';
                }
            });
        } else {
            Swal.fire({
                title: 'Erreur!',
                icon: 'error',
                confirmButtonText: 'Ok',
                allowOutsideClick: false
            });
        }
    } catch (error) {
        Swal.fire({
            title: 'Erreur inconnue!',
            text: 'Une erreur inattendue s\'est produite. Veuillez réessayer plus tard ou contacter le support.',
            icon: 'error',
            timer: 1000,
            showConfirmButton: false,
            allowOutsideClick: false
        }).then(function () {
            window.location.href = '/';
        });
    }
});


===== ./stacked.js =====
let chartInstance;
const frenchMonths = ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'];

const monthColors = [
    '#1f77b4', // Blue - Janvier
    '#ff7f0e', // Orange - Février
    '#2ca02c', // Green - Mars
    '#d62728', // Red - Avril
    '#9467bd', // Purple - Mai
    '#8c564b', // Brown - Juin
    '#e377c2', // Pink - Juillet
    '#7f7f7f', // Gray - Août
    '#bcbd22', // Yellow-Green - Septembre
    '#17becf', // Cyan - Octobre
    '#bc79af', // Plum - Novembre
    '#aec7e8'  // Light Blue - Décembre
];

async function updateChart() {
    const year = document.getElementById('yearSelect').value;

    try {
        const response = await fetch(`/charts/stacked-data?year=${year}`);
        if (!response.ok) throw new Error('Échec du chargement des données');
        const data = await response.json();

        renderTable(data);
        renderChart(data);
    } catch (error) {
        console.error(error);
        alert('Une erreur s\'est produite lors du chargement des données');
    }
}

function getActiveMonths(data) {
    const activeMonths = [];
    for (let month = 1; month <= 12; month++) {
        let hasData = false;
        for (const user in data) {
            if (data[user][month - 1] > 0) {
                hasData = true;
                break;
            }
        }
        if (hasData) activeMonths.push(month);
    }
    return activeMonths;
}

function renderTable(data) {
    const tableBody = document.getElementById('tableBody');
    const tableHead = document.querySelector('#propositionsTable thead tr');
    tableBody.innerHTML = '';
    tableHead.innerHTML = '';

    const activeMonths = getActiveMonths(data);
    const activeMonthNames = activeMonths.map(month => frenchMonths[month - 1]);

    const userHeader = document.createElement('th');
    userHeader.textContent = 'Utilisateur';
    tableHead.appendChild(userHeader);

    activeMonthNames.forEach(month => {
        const monthHeader = document.createElement('th');
        monthHeader.textContent = month;
        tableHead.appendChild(monthHeader);
    });

    const totalHeader = document.createElement('th');
    totalHeader.textContent = 'Total';
    tableHead.appendChild(totalHeader);

    Object.keys(data).forEach(username => {
        const row = document.createElement('tr');
        const userData = data[username];

        const userCell = document.createElement('td');
        userCell.textContent = username;
        row.appendChild(userCell);

        let total = 0;
        activeMonths.forEach(month => {
            const cell = document.createElement('td');
            const count = userData[month - 1] || 0;
            cell.textContent = count;
            row.appendChild(cell);
            total += count;
        });

        const totalCell = document.createElement('td');
        totalCell.textContent = total;
        row.appendChild(totalCell);

        tableBody.appendChild(row);
    });

    const totalRow = document.createElement('tr');
    const totalLabelCell = document.createElement('td');
    totalLabelCell.textContent = 'Total par mois';
    totalLabelCell.style.fontWeight = 'bold';
    totalRow.appendChild(totalLabelCell);

    activeMonths.forEach(month => {
        let monthTotal = 0;
        Object.keys(data).forEach(username => {
            monthTotal += data[username][month - 1] || 0;
        });
        const monthTotalCell = document.createElement('td');
        monthTotalCell.textContent = monthTotal;
        totalRow.appendChild(monthTotalCell);
    });

    const grandTotal = activeMonths.reduce((total, month) => {
        return total + Object.keys(data).reduce((userTotal, username) => {
            return userTotal + (data[username][month - 1] || 0);
        }, 0);
    }, 0);

    const grandTotalCell = document.createElement('td');
    grandTotalCell.textContent = grandTotal;
    totalRow.appendChild(grandTotalCell);

    tableBody.appendChild(totalRow);
}

function renderChart(data) {
    const ctx = document.getElementById('stackedChart').getContext('2d');
    const activeMonths = getActiveMonths(data);
    const activeMonthNames = activeMonths.map(month => frenchMonths[month - 1]);
    const users = Object.keys(data);
    const datasets = [];

    activeMonths.forEach(month => {
        datasets.push({
            label: frenchMonths[month - 1],
            data: users.map(username => data[username][month - 1] || 0),
            backgroundColor: monthColors[month - 1],
            borderColor: 'rgba(0, 0, 0, 0.1)',
            borderWidth: 1,
        });
    });

    if (chartInstance) {
        chartInstance.destroy();
    }

    chartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: users,
            datasets: datasets
        },
        options: {
            responsive: true,
            plugins: {
                legend: {
                    position: 'top',
                },
            },
            scales: {
                x: {
                    stacked: true,
                },
                y: {
                    stacked: true,
                }
            }
        }
    });
}


window.onload = () => {
    updateChart();
};


===== ./status.js =====
function checkActiveSession() {
    fetch('/voting-sessions/check-active-session')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                if (data.sessionType === "jury") {
                    document.querySelector('.container').innerHTML = `
              <p class="info">Une session de vote de jury est active, voulez-vous entrer ?</p>
              <button class="btn" onclick="window.location.href='/voting-sessions/current-proposition'">Entrer</button>
              <button class="btn" onclick="history.back()">Retour</button>`;
                } else if (data.sessionType === "user") {
                    document.querySelector('.container').innerHTML = `
              <p class="info">Une session de vote globale a été trouvée.</p>
              <button class="btn" onclick="window.location.href='/voting-sessions/global-vote'">Démarrer</button>
              <button class="btn" onclick="history.back()">Retour</button>`;
                }
            } else {
                document.querySelector('.container').innerHTML = `
            <p class="info">Aucune session active n'a été trouvée.</p>
            <button class="btn" onclick="history.back()">Retour</button>`;
            }
        })
        .catch(error => console.error('Error fetching session status:', error));
}

setInterval(checkActiveSession, 5000);

checkActiveSession();

